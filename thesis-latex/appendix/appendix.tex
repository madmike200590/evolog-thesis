\chapter{Additional Material}

\section{Installing Alpha}

\paragraph{Using a pre-built binary file}
The Alpha ASP solver is written in Java. In order to run it, a Java Runtime Environment (JRE) compatible with Java 11 (i.e. Version 11 or newer) is required. Alpha builds can be obtained from the Github page\footnote{\url{https://github.com/alpha-asp/Alpha/releases}}.

The artifact required to run Alpha is the bundled jar file containing the commandline application, i.e. \texttt{alpha-cli-app-\$\{version\}-bundled.jar}.

In order to solve an ASP program stored in file \texttt{program.asp}, run the jar file as demonstrated in Listing~\ref{lst:appendix-run-alpha}.
\begin{lstlisting}[style=code, label={lst:appendix-run-alpha}, caption={Solving an ASP program using Alpha.}]
$>java -jar /path/to/alpha/
	alpha-cli-app-x.y.z-bundled.jar -i program.asp
\end{lstlisting}	

In order to run the Alpha jar from any location in the file system without always having to enter the full path to the jar, one can create a launcher script for Alpha. This launcher script then needs to be placed in a directory that is included in the system's \texttt{PATH} environment variable (e.g. \texttt{/usr/local/bin} on most Linux systems). Listing~\ref{lst:appendix-launcher-linux} shows a launcher script suitable for a Linux system (i.e. in the Bash scripting language) which assumes the Alpha jar for Alpha version 0.8.0 to be stored in \texttt{/usr/local/bin}.
\begin{lstlisting}[style=asp-code, label={lst:appendix-launcher-linux}, caption={Bash launcher script for Alpha.}]
#!/bin/bash

java -jar /usr/local/bin/alpha-cli-app-0.8.0-bundled.jar $@
\end{lstlisting}	

Listing~\ref{lst:appendix-launcher-windoze} shows a Windows-compatible script which assumes that the Alpha jar is stored in \texttt{C:/Program Files/alpha-asp}.
\begin{lstlisting}[style=asp-code, label={lst:appendix-launcher-windoze}, caption={Windows-Batch launcher script for Alpha.}]
java -jar "C:\Program Files\alpha-asp\alpha-cli-app-0.8.0-SNAPSHOT-bundled.jar" %*
\end{lstlisting}	

Using a central launcher script, Alpha can be called through the name of the launcher script from any working directory. This is demonstrated in Listing~\ref{lst:appendix-use-launcher}, where \texttt{alpha-solver} is assumed as name of the launcher script.
\begin{lstlisting}[style=code, label={lst:appendix-use-launcher}, caption={Solving an ASP program using Alpha through a launcher script.}]
$>alpha-solver -i program.asp
\end{lstlisting}

\paragraph{Building Alpha from source code}
As an alternative to using a pre-build binary package, Alpha can also be built from sources. For this, a Java Development Kit (JDK) compatible with Java 11 is required. In order to build Alpha, clone the git repository\footnote{\url{https://github.com/alpha-asp/Alpha.git}} and start the build through the Gradle Wrapper script as demonstrated in Listing~\ref{lst:appendix:build-alpha}. The actual executable jar is built using the gralde task \emph{bundledJar}, but to make sure all automated tests succeed as expected, is it recommended to run a full build (using taks \emph{build}) first. After the \emph{bundledJar} task has completed, the executable file is located in the build directory of the \texttt{alpha-cli-app} module.
\begin{lstlisting}[style=code, label={lst:appendix-build-alpha}, caption={Building Alpha from source code.}]
$>git clone https://github.com/alpha-asp/Alpha.git
$>cd Alpha
$>./gradlew build
$>./gradlew bundledJar
$>java -jar alpha-cli-app/build/libs/alpha-cli-app-0.8.0-bundled.jar -i program.asp
\end{lstlisting}	

\section{Running ASP code with Alpha}

TODO: Debugging features of CLI application, basic API usage.

\section{Examples}
\begin{example}[Fibonacci-Numbers using external atoms]
\label{ex:user-supplied-externals}
The following code snippet demonstrates how to run a program which includes user-supplied external atoms using Alpha. Since the Alpha Commandline-App currently does not support loading Atom Definitions from jar files, the solver is directly called from Java code in this example.\\
\\
In this example, we use an external predicate definition \texttt{fibonacci\_number/2} to efficiently calculate Fibonacci numbers. The actual ASP program generates all Fibonacci numbers up to index 40 that are even. The ASP program is shown in Listing~\ref{lst:user-supplied-externals-asp}, while Listing~\ref{lst:user-supplied-externals-java} shows the Java implementation of the external predicate.
\begin{lstlisting}[style=asp-code, label={lst:user-supplied-externals-asp}, caption={ASP program to find even Fibonacci numbers.}]
%% Find even fibonacci numbers up to F(40).
fib(N, FN) :- &fibonacci_number[N](FN), N = 0..40.
even_fib(N, FN) :- fib(N, FN), FN \ 2 = 0.    
\end{lstlisting}    
The Java implementation of the \texttt{fibonacci\_number/2} predicate makes use of \emph{Binet's Formula}\todo{can we cite something here?} to efficiently compute Fibonacci numbers using a closed form expression of the sequence.
\begin{lstlisting}[style=java, label={lst:user-supplied-externals-java}, caption={Fibonacci number computation in Java.}]
public class CustomExternals {

	private static final double GOLDEN_RATIO = 1.618033988749894;
	private static final double SQRT_5 = Math.sqrt(5.0);

	/**
	 * Calculates the n-th Fibonacci number using a variant of Binet's Formula
	 */
	$$@Predicate(name="fibonacci_number")
	public static Set<List<ConstantTerm<Integer>>> fibonacciNumber(int n) {
		return Set.of(List.of(Terms.newConstant(binetRounding(n))));
	}

	public static int binetRounding(int n) {
		return (int) Math.round(Math.pow(GOLDEN_RATIO, n) / SQRT_5);
	}

}    
\end{lstlisting}    
The Alpha solver is invoked from a simple Java method, which uses Alpha's API to first compile the external atom definition, and then run the solving process for the parsed ASP program. This is illustrated in Listing~\ref{lst:user-supplied-externals-main}
\begin{lstlisting}[style=java, label={lst:user-supplied-externals-main}]
public class CustomExternalsApp {

	public static void main(String[] args) throws IOException {
		Alpha alpha = AlphaFactory.newAlpha();
		Map<String, PredicateInterpretation> customExternals =
			Externals.scan(CustomExternals.class);
		String aspCode =
			Files.readString(
				Paths.get("src/main/resources/customExternals.asp"));
				InputProgram program =
					alpha.readProgramString(aspCode,
				customExternals);
		alpha.solve(program).forEach(as -> {
			System.out.println("Answer set:\n" + as);
		});
	}

}
\end{lstlisting}
\end{example}

\begin{example}[Module Parsing]
\label{ex:alpha-module-parsing}	
Listing~\ref{lst:apdx-alpha-module-grammar} shows the actual ANTLR-grammar used in Alpha to parse module definitions. Parsed Module Definitions are stored in instances of the \texttt{Module} type. Listing~\ref{lst:apdx-alpha-module-def} shows the corresponding Java interface definition.
\begin{lstlisting}[style=asp-code, label={lst:apdx-alpha-module-grammar}, caption={ANTLR grammar for module definitions}]
directive_module: 
	SHARP DIRECTIVE_MODULE id 
		PAREN_OPEN module_signature PAREN_CLOSE 
			CURLY_OPEN statements CURLY_CLOSE;

module_signature : 
	predicate_spec ARROW CURLY_OPEN 
		('*' | predicate_specs) CURLY_CLOSE;	

predicate_specs: 
	predicate_spec (COMMA predicate_specs)?;

predicate_spec: id '/' NUMBER;
\end{lstlisting}
Note how the \texttt{module\_signature} rule permits the shorthand \texttt{*} instead of an output predicate list.
This is used as a shorthand to express the list of all predicates derived by any rule in the module (i.e. emit full, unfiltered answer sets).	
\begin{lstlisting}[style=java, label={lst:apdx-alpha-module-def}, caption={Java interface specifying Alpha's internal representation of a module definition.}]
public interface Module {

	String getName();

	Predicate getInputSpec();

	Set<Predicate> getOutputSpec();

	InputProgram getImplementation();

}	
\end{lstlisting}	
\end{example}	
