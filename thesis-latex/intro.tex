\gls{asp} is a formalism for declarative problem solving based on the Stable Model semantics introduced by Gelfond and Lifschitz in~\cite{stable-models}. Since its inception in 1988, it has been applied in a wide range of fields such as logistics~\cite{gioia-tauro}~\cite{train-scheduling}, automated music composition~\cite{blues-composition} and even spaceflight~\cite{space-shuttle}. Apart from the established use of \gls{asp} as a formalization language for decision- or optimization problems, more recent developments in the field are increasingly targeted toward working with continuous external data in \gls{asp} programs. A prominent example from this direction of research is the stream reasoning system LARS~\cite{lars}. This thesis takes a different approach to interacting with external data sources as well as time progression in ASP programs. We specify and implement Evolog, an extension of the lazy-grounding \gls{asp} solver Alpha~\cite{alpha} which aims to upgrade the ASP variant understood by Alpha to something resembling a general-purpose programming language with the goal of being able to write arbitrary programs in a language based on \gls{asp}. In the following, we state the design goals for said language extension we deem necessary to achieve this goal.

\section{Problem Statement}

\paragraph{Triggering actions from programs} \label{goals:actions}Most program flows follow a chain of events, each a consequence of its predecessor, e.g. "If there exists a file A, read it. If reading was successful, do something with the content. If the operation succeeds, write the result to file B". It is highly desirable to be able to write this kind of program in a declarative, logic-based language that can leverage the strengths of ASP for the "business logic" part. Specifically, the proposed action semantics should deliver
\begin{itemize}
    \item declarative programs, i.e. order in which actions occur in code does not affect semantics,
    \item actions behaving in a functional fashion, i.e. an action always gives the same result for the same input. Especially, actions have to be idempotent in the sense that, for an ASP rule that is associated with some action, the result of the action never changes, no matter how often the rule fires.
    \item transparent action execution, i.e. every action that is executed during evaluation of a program must be reflected in an answer set.
\end{itemize}

\paragraph{Program Modularization} While not formally connected, triggering actions from programs and modularization (i.e. plugable and re-usable sub-programs), intuitively complement each other in our current high-level design. Introducing a simple, easy-to-use module system is therefore the second goal of this work. It is, however, secondary in priority to definition and prototypical implementation of action support and may be reduced to a technical design draft if required due to time constraints.

\paragraph{Incremental Evaluation and Lazy Grounding} Experiences from existing systems for ASP application development such as ASAP~\cite{aspetris} or ACTHEX~\cite{acthex} show that, in order to achieve the evaluation performance necessary for use in real-world applications, ASP application code needs to be evaluated in an incremental fashion (rather than iteratively re-evaluating the whole program) whenever possible. The lazy-grounding architecture employed by ASP systems such as Alpha~\cite{alpha} offers an intuitive solution.

\section{State of the Art}
\todo{Just copied from proposal for now -- polish this!}
This work aims to blend action support with modularization in the context of lazy-grounding ASP solving - all three of these areas have seen a substantial amount of research in the past.

Both Clingo~\cite{clingo4} and DLVHEX, through the ACTHEX~\cite{acthex} extension, offer their own flavours of support for triggering actions from programs. While Clingo does not directly support actions as a dedicated feature - and therefore offers no strictly enforced semantics for this - similar behavior can be achieved using external functions and the reactive solving features first introduced in oClingo~\cite{oclingo}. ACTHEX has thoroughly defined semantics for actions. In the ACTHEX model, answer set search and action execution are separate steps, where executability of actions is only determined after answer sets are calculated. While this gives users a high degree of flexibility in working with actions, it does not directly lend itself to the idea of a general purpose language where program behavior may be influenced by continuous two-way communication between a program and its environment.

With regards to Modularity, i.e. the process of "assembling" an ASP program from smaller building blocks (i.e. modules), a comprehensive semantics for so-called ~\emph{nonmonotonic modular logic programs} has been introduced in~\cite{mlp-krennw} and~\cite{mlp-2009}. While it does not impose any restrictions on language constructs used in modules and recursion within and between modules, it also comes with rather high computational complexity and no easily available implementations so far. A more "lightweight" approach to modularization are \emph{Templates}~\cite{templates}. As the name implies, this purely syntactic approach aims to define isolated sub-programs that can be generically used to avoid code duplication throughout an application and is conceptually similar to the well-known generics in object-oriented languages such as C++ and Java. Templates are rewritten into regular ASP rules using an "explosion" algorithm which basically "instantiates" the template by generating the needed body atoms (and rules deriving them) wherever templates are used. While easy to implement and flexible, a potential disadvantage of this concept is that - due to its purely syntactical nature - programmers need to be on the watch for potential bugs arising from unintended cyclic dependencies or recursive use of templates (leading to potential non-termination of the explosion algorithm) themselves.
Yet another powerful toolset for modular application development is provided by Clingo's \emph{multi-shot-solving}~\cite{clingo-multishot} features. Clingo allows for parameterized sub-programs which are then repeatedly grounded in a process that is conceptually similar to the notion of module instantiation in ~\cite{modules-compositionality} and solved during solving of the overall program. However, as this "contextual grounding" needs to be programmatically controlled by an external application through Clingo's API, the inherent flexibility and usefulness for incremental solving of this approach is counterweighed by a high level of proficiency with and knowledge of the Clingo system necessary to leverage these capabilites.
The concept of \emph{lazy grounding}, i.e. interleaving of the - traditionally sequential - grounding and solving steps present in most prevalent ASP solvers, is relatively new. It has been spearheaded by the GASP~\cite{gasp} and ASPERIX~\cite{asperix-fw-chain} solvers which avoid calculating the full grounding of an input program by performing semi-naive bottom-up evaluation along the input's topologically sorted (non-ground) dependency graph. While efficient in terms of memory use, this approach cannot stand up to the solving performance of systems like DLV or Clingo which employ their knowledge of all possible ground rules to perform conflict-driven nogood learning (CDNL) as part of their solving algorithm to great effect. Alpha~\cite{alpha}, a more recent lazy-grounding solver, aims to bridge this gap in performance by employing CDNL-style solving techniques~\cite{lazy-cdnl} incrementally on partially ground program parts as part of its central ground-and-solve loop.

Conceptually, the common ingredient linking the - on first glance not directly connected - areas of actions in ASP, program modularization, and lazy grounding is a need for detailed static program analysis prior to solving, be it to detect potentially invalid action sequences, calculate module instantiation orders, or for up-front evaluation of stratified program parts in a lazy-grounding context. In addition, both actions and modularization can greatly benefit from - or even depend on - incremental evaluation facilities of a solver for efficient operation. Since lazy-grounding by its very definition embodies an incremental evaluation approach, it seems only natural to incorporate actions and modularization into a lazy-grounding solver's input language in order to provide ASP programmers with a powerful tool for application development. Alpha, with its good solving performance compared to other lazy-grounding systems, support for a large part of the current ASP-Core2 language standard, and active development status, appears the natural choice as the technical backbone of this work.
