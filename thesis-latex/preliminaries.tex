\section{Answer Set Programming}

When speaking of \emph{answer set programming}, we nowadays mostly refer to the language specfied by the ASP-Core2 standard~\cite{asp-core2}. It uses the \emph{stable model semantics} by Gelfond and Lifschitz~\cite{stable-models} as a formal basis and enhances it with support for advanced concepts such as disjunctive programs, aggregate literals and weak constraints. This chapter describes the input language supported by the Alpha solver, which will serve as the basis on which we will define the Evolog language.

\todo{abbreviations!}

\subsection{Syntax}
\label{subsec:prelims-asp-syntax}

\begin{definition}[Integer numeral]
\label{def:prelims-asp-syntax-int}
An \emph{integer numeral} in the context of an ASP program is a string matching the regular expression:
\begin{lstlisting}[style=code]
(-)?[0-9]+
\end{lstlisting}
The set of all valid integer numerals is denoted as $\INTs$.
\end{definition}

\begin{definition}[Identifier]
\label{def:prelims-asp-syntax-id}
An \emph{identifier} in the context of an ASP program is a string matching the regular expression:
\begin{lstlisting}[style=code]
[a-z][a-zA-Z0-9\_]*
\end{lstlisting}
The set of all valid identifiers is denoted as $\IDs$.
\end{definition}

\begin{definition}[Variable Name]
\label{def:prelims-asp-syntax-var}
A \emph{variable name} in the context of an ASP program is a string matching the regular expression:
\begin{lstlisting}[style=code]
[A-Z][a-zA-Z0-9\_]*
\end{lstlisting}
The set of all valid variable names is denoted as $\VARs$.
\end{definition}

\begin{definition}[Term]
\label{def:prelims-asp-syntax-term}
A \emph{term} is inductively defined as follows:
\begin{itemize}
	\item Any \emph{constant} $c \in (\INTs \cup \IDs)$ is a term.
	\item Any \emph{variable} $v \in \VARs$ is a term.
	\item Given terms $t_1, t_2$, any \emph{artihmetic expression} $t_1 \oplus t_2$ with $\oplus \in \{+, - , *, /, **\}$ is a term.
	\item Given terms $t_1, t_2$, any \emph{interval expression} $t_1 \ldots t_2$ is a term.
	\item For function symbol $f \in \IDs$ and argument terms $t_1, \ldots, t_n$, the \emph{functional expression} $f(t_1, \ldots, t_n)$ is a term.
\end{itemize}
\end{definition}

\begin{definition}[Subterms]
\label{def:prelims-asp-syntax-subterms}
Given a term $t$, the set of \emph{subterms} of $t$, $st(t)$, is defined as follows:
\begin{itemize}
	\item If $t$ is a \emph{constant} or \emph{variable}, $st(t) = \{t\}$.
	\item If $t$ is an \emph{arithmetic expression} $t_1 \oplus t_2$, $st(t) = st(t_1) \cup st(t_2)$.
	\item If $t$ is an \emph{interval expression} $t_1 \ldots t_2$, $st(t) = st(t_1) \cup st(t_2)$.
	\item If $t$ is a \emph{functional expression} with argument terms $t_1, \ldots, t_n$, $st(t) = st(t_1) \cup \ldots \cup st(t_n)$.
\end{itemize}
A term is called \emph{ground} if it is variable-free, i.e. none of its subterms is a variable.
\end{definition}

\begin{definition}[Atom]
\label{def:prelims-asp-syntax-atom}
Given a predicate symbol $p \in \IDs$ and argument terms $t_1,\ldots,t_n$, the expression
\[
	p(t_1,\ldots,t_n)
\]
is called an \emph{atom}. An atom is ground if all of its argument terms are ground. A ground atom with predicate $p$ is called an \emph{instance} of $p$.
\end{definition}

\begin{definition}[Literal]
\label{def:prelims-asp-syntax-literal}
A literal in ASP is an atom $a$ or ("default"-)negated atom $\NOT\ a$.
\end{definition}

\begin{definition}[Rule, Program]
\label{def:prelims-asp-syntax-rule}
A \emph{rule} is an expression of form
\[
	a_H \leftarrow b_1,\ldots,b_n.
\]
for $n \geq 0$, where the \emph{rule head} $a_H$ is an atom and the \emph{rule body} $b_1,\ldots,b_n$ is a set of literals. An ASP \emph{program} is a set of rules. A rule with an empty body is called a \emph{fact}. A rule is \emph{ground} if both its head atom and all of its body literals are ground. By the same reasoning, a program is ground if all of its rules are ground.
\end{definition}

\begin{definition}[Constraint]
\label{def:prelims-asp-syntax-constraint}
A \emph{constraint} is a special form of rule, written as a rule with an empty head, i.e.
\[
	\leftarrow b_1,\ldots,b_n.
\]
It is snytactic sugar for
\[
	q \leftarrow b_1,\ldots,b_n, \NOT\ q.
\]
where $q$ is a propositional constant not occurring in any other rule in the program.
\end{definition}

\subsection{Semantics}
\label{subsec:prelims-asp-semantics}

\begin{definition}[Herbrand Universe]
\label{def:prelims-asp-semantics-hu}
The Herbrand Universe $HU_P$ of a Program $P$ is the set of all valid terms that can be constructed with respect to Definitions~\ref{def:prelims-asp-syntax-int},~\ref{def:prelims-asp-syntax-id} and \ref{def:prelims-asp-syntax-term}.
Note that most papers use stricter definition of the Herbrand Universe where $HU_P$ consists only of terms constructible from constants occurring in $P$. The broader definition used here is chosen for ease of definition with respect to some of the extensions introduced in Section~\ref{sec:evolog-actions}.
\end{definition}

\begin{definition}[Herbrand Base]
\label{def:prelims-asp-semantics-hb}
The Herbrand Base $HB_P$ of a Program $P$ is the set of all ground atoms that can be constructed from the Herbrand Universe $HU_P$ according to definition~\ref{def:prelims-asp-syntax-atom}. 
\end{definition}

\begin{definition}[Herbrand Interpretation]
\label{def:prelims-asp-semantics-herbrand-interpretation}
A Herbrand Interpretation is a special form of first order interpretation where the domain of the interpretation is a Herbrand Universe and terms are the interpretation of a term is the term itself, i.e. the corresponding element of $HU_P$. Intuitively, Herbrand Interpretations constitute listings of atoms that are true in a given program.
\end{definition}

\subsubsection{Grounding}
\label{subsubsec:prelims-grounding}
Given a program $P$ containing variables, \emph{grounding} refers to the process of converting $P$ into a semantically equivalent propositional, i.e. variable-free, program.

\begin{definition}[Substitution, adapted from~\cite{lazy-cdnl}]
\label{def:prelims-asp-semantics-substitution}
A substitution $\sigma: \VARs \mapsto (\IDs \cup \INTs)$ is a mapping from variables to constants. For a atom $a$, applying a a substitution results in a substituted atom $a\sigma$ in which variables are replaced according to $\sigma$. Substitutions are applied to rules  by applying them to every individual atom or literal within the rule. By the same mechanism, we can apply substitutions to programs by applying the to all rules.
\end{definition}

\begin{definition}[Grounding]
\label{def:prelims-asp-semantics-grounding}
Given a rule $r$, the \emph{grounding} of $r$, $\mathit{grnd}(r)$, is a set of substitutions $S$, such that the set of ground rules resulting from applying the substitutions in $S$ is semantically equivalent to $r$.
\end{definition}