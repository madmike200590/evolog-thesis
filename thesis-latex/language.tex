The Evolog language extends (non-disjunctive) ASP as defined in the ASP-Core2 standard~\cite{asp-core2} with facilities to communicate with and influence the "outside world" (e.g. read and write files, capture user input, etc.) as well as program modularization and reusability features, namely \emph{actions} and \emph{modules}.

\section{Actions in Evolog}
\label{sec:evolog-actions}

Actions allow for an ASP program to encode operations with \emph{side-effects} while maintaining fully declarative semantics. Actions are modelled in a functional style loosely based on the concept of monads as used in Haskell~\todo{cite something here!}. Intuitively, to maintain declarative semantics, actions need to behave as pure functions, meaning the result of executing an action (i.e. evaluating the respective function) must be reproducible for each input value across all executions. On first glance, this seems to contradict the nature of IO operations, which inherently depend on some state, e.g. the result of evaluating a function $getFileHandle(f)$ for a file $f$ will be different depending on whether $f$ exists, is readable, etc. However, at any given point in time - in other words, in a given state of the world - the operation will have exactly one result (i.e. a file handle or an error will be returned). A possible solution to making state-dependent operations behave as functions is therefore to make the state of the world at the time of evaluation part of the function's input. A function $f(x)$ is then turned into $f'(s, x)$  where $s$ represents a specific world state. The rest of this section deals with formalizing this notion of actions.

\todo{Define non-disjunctive ASP-Core2 in detail in preliminaries. Give detailed definition of all "standard ASP" elements referenced here!}

\subsection{Syntax}
\label{subsec:evolog-actions-syntax}

\begin{definition}[Action Rule, Action Program]
\label{def:action-rule-syntax}
An \emph{action rule} $R$ is of form
\[
	a_H : @t_{act} = act_{res} \leftarrow l_1,\ldots,l_n.
\]
where
\begin{itemize}
	\item $a_H$ is an atom called \emph{head atom},
	\item $t_{act}$ is a functional term called \emph{action term},
	\item $act_{res}$ is a term called \emph{(action-)result} term
	\item and $l_1,\ldots,l_n$ are literals constituting the \emph{body} of $R$.
\end{itemize}
An \emph{action program} $P$ is a set of (classic ASP-)rules and action rules.
\end{definition}

\subsection{Semantics}
\label{subsec:evolog-actions-semantics}

To properly define the semantics of an action program according to the intuition outlined at the start of this section, we first need to formalize our view of the "outside world" which action rules interact with. We call the world in which we execute a program a \emph{frame} - formally, action programs are always evaluated \emph{with respect to a given frame}. The behavior of actions is specified in terms of \emph{action functions}. The semantics (i.e. interpretations) of action functions in a program are defined by the respective frame.

\subsubsection{Action Rule Expansion}
\label{subsubsec:evolog-actions-semantics-expansion}

To get from the practical-minded action syntax from Definition~\ref{def:action-rule-syntax} to the formal representation of an action as a function of some state and an input, we use the helper construct of an action rule's \emph{expansion} to bridge the gap. Intuitively, the expansion of an action rule is a syntactic transformation that results in a more verbose version of the original rule called \emph{application rule} and a second rule only dependent on the application rule called \emph{projection rule}. A (ground) application rule's head atom uniquely identifies the ground instance of the rule that derived it. As one such atom corresponds to one action executed, we call a ground instance of an application rule head in an answer set an \emph{action witness}. 

\todo{define (classic ASP) grounding and substitutions in preliminaries}

\begin{definition}[Action Rule Expansion]
\label{def:action-rule-expansion}
Given a non-ground action rule $R$ with head atom $a_H$, action term $f_{act}(i_1,\ldots,i_n)$ and body  $B$ consisting of literals $l_1,\ldots,l_m$, the expansion of $R$ is a pair of rules consisting of an \emph{application rule} $R_{app}$ and \emph{projection rule} $R_{proj}$. $R_{app}$ is defined as
\[
	a_{res}(f_{act}, S, I, f_{act}(S, I)) \leftarrow l_1,\ldots,l_n.
\]
where $S$ and $I$ and function terms called \emph{state-} and \emph{input-}terms, respectively.
An action rule's state term has the function symbol $\mathit{state}$ and terms $fn(l_1),\ldots,fn(l_m)$, with the expression $fn(l)$ for a literal $l$ denoting a function term representing $l$. The (function-)term representation of a literal $p(t_1,\ldots,t_n)$ with predicate symbol $p$ and terms $t_1,\ldots,t_n$ uses $p$ as function symbol. For a negated literal $\mathit{not}~p(t_1,\ldots,t_n)$, the representing function term is $not(p(t_1,\ldots,p_n))$. The action input term is a "wrapped" version of all arguments of the action term, i.e. for action term $f_{act}(t_1,\ldots,t_n)$, the corresponding input term is $input(t_1,\ldots,t_n)$. The term $f_{act}(S, I)$ is called \emph{action application term}. \\
The projection rule $R_{proj}$ is defined as
\[
	a_H \leftarrow a_{res}(f_{act}, S, I, v_{res}).
\]
where $a_H$ is the head atom of the initial action rule $R$ and the (sole) body atom is the action witness derived by $R_{app}$, with the application term $f_{act}(S, I)$ replaced by a variable $v_{res}$ called \emph{action result variable}.
\end{definition}

Looking at the head of an action application rule of format $a_{res}(f_{act}, S, I, \mathit{t_{app}})$ with action $f_{act}$, state term $S$, input term $I$ and application term $t_{app}$, the intuitive reading of this atom is "The result of action function $f_{act}$ applied to state $S$ and input $I$ is $t_{app}$", i.e. the action application term $t_{app}$ is not a regular (uninterpreted) function term as in regular ASP, but an actual function call which is resolved using an interpretation function provided by a \emph{frame} during grounding.

%% NOTE: Action func. term is uninterpreted in nonground view! Application formally happens during grounding, i.e. action func is applied in grounding, ground version has action result.

\subsubsection{Grounding of Action Rules}
\label{subsubsec:evolog-actions-semantics-grounding}

Grounding, in the context of answer set programming, generally refers to the conversion of a program with variables into a semantically equivalent, variable-free, version. Action application terms as introduced in Definition \ref{def:action-rule-expansion} can be intuitively read as variables, in the sense that they represent the result of applying the respective action function. Consequently, all action application terms are replaced with the respective (ground) result terms defined in the \emph{frame} with respect to which the program is grounded.

\begin{definition}[Frame]
\label{def:evolog-frame}
Given an action program $P$ containing action application terms $A = \{a_1,\ldots,a_n\}$, a frame $F$ is an interpretation function such that, for each application term $f_{act}(S, I) \in A$ where $S \in H_{U}(P)^{*}$ and $I \in H_{U}(P)^{*}$, $F(f_{act}): H_{U}(P)^{*} \times H_{U}(P)^{*} \mapsto H_{U}(P)$.
\end{definition}

\begin{definition}[Grounding of action rules]
\label{def:evolog-grounding}
Grounding of Evolog rules (and programs) always happens \emph{with respect to a frame}. Given a frame $F$, an expanded action rule $r_a$ and a (grounding) substitution $\sigma$ over all body variables of application rule $r_{a_{app}}$, during grounding, every ground action application term $t_{app}\sigma$ resulting from applying substitution $\sigma$ is replaced with its interpretation according to $F$.
\end{definition}

Example \ref{ex:action-rule-expansion} demonstrates the expansion of an action rule as well as a compatible example frame for the respective action.

\begin{example}[Expansion and Frame]
\label{ex:action-rule-expansion}
Consider following Evolog Program $P$ which contains an action rule with action $a$:
\begin{align*}
	&p(a).~q(b).~r(c). \\
	&h(X, R) : @a(X, Z) = R \leftarrow p(X), q(Y), r(Z).
\end{align*}
The expansion of $R$ is:
\begin{align*}
	a_{res}(a, \mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z), a(\mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z))) \leftarrow& \\
	p(X), q(Y), r(Z).& \\
	h(X, R) \leftarrow a_{res}(a, \mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z), R).&
\end{align*}
Furthermore, consider following frame $F$:
\[
	F(a) = \{a(\mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c)) \mapsto \mathit{success}(a, c)\}
\]
which assigns the result $\mathit{success}(a, c)$ to the action application term (i.e. function call $a(\mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c)))$. \\

Then, the ground program $P_{grnd}$ after action rule expansion is
\begin{align*}
	p(a).~q(b).~r(c).& \\
	a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c)) \leftarrow p(a).~q(b).~r(c).& \\
	h(a, \mathit{success}(a, c)) \leftarrow a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c)).&
\end{align*}
The sole model of $P$ with respect to frame $F$ is 
\begin{align*}
	M = \{p(a), q(b), r(c),& \\
	a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c))& \\ h(a, \mathit{success}(a, c))\}&
\end{align*}
\end{example}

\subsubsection{Evolog Models}
\label{subsubsec:evolog-action-semantics-models}

Having introduced action rule expansions as well as frames, we now use these to extend the stable model semantics to Evolog programs.

\begin{definition}[Supportedness of Actions]
\label{def:evolog-supported-action}
Let $r_{app}$ be a non-ground action application rule with head $H = a_{res}(f_{act}, S, I, f_{act}(S, I))$, $F$ a frame, and $H_{grnd} = a_{res}(f_{act}, S_{grnd}, I_{grnd}, r)$ a ground instance of $H$ with $r$ being an arbitrary ground term.
Then, $H_{grnd}$ is \emph{supported by $F$}, if and only if $F$ contains a mapping of form $f_{act}(S_{grnd}, I_{grnd}) \mapsto r$, i.e. $r$ is a valid result of action function $f_{act}$ with arguments $S_{grnd}$ and $I_{grnd}$ according to frame $F$. 
We call a ground instance of an action rule \emph{supported by a frame} if the head of the corresponding application rule in the rule's expansion is supported by that frame.
\end{definition}

\begin{definition}[Evolog-Reduct]
\label{def:evolog-reduct}
Given a ground Evolog program $P$, a frame $F$ and a set of ground atoms $A$, the \emph{Evolog Reduct} of $P$ with respect to $F$ and $A$ $P_{F}^{A}$ is obtained from $P$ as follows:
\begin{enumerate}
	\item Remove all rules $r$ from $P$ that are "blocked", i.e. $A \not\models l$ for some negative body literal $l \in b^{-}(r)$.
	\item Remove all action application rules from $P$ which are not supported by $F$.
	\item Remove the negative body from all other rules.
\end{enumerate}
\end{definition}

Note that the reduct outlined in Definition \ref{def:evolog-reduct} extends the classic GL-reduct (see Definition \ref{def:prelims-asp-semantics-gl-reduct}) just by adding a check on action supportedness.

\begin{definition}[Evolog Model]
A herbrand interpretation $I$ of an Evolog Program is an \emph{Evolog Model} ("answer set") of an Evolog program $P$ with respect to a frame $F$ if and only if it is a minimal classical model of its Evolog-Reduct $P_{F}^{A}$. We denote the set of Evolog Models of a program $P$ as $\mathit{EM}(P)$.
\end{definition}

\subsection{Restrictions on Program Structure}
\label{subsec:evolog-actions-restrictions}

% Following goals are listed in introduction
%     \item declarative programs, i.e. order in which actions occur in code does not affect semantics,
%     \item actions behaving in a functional fashion, i.e. an action always gives the same result for the
%      same input. Especially, actions have to be idempotent in the sense that, for an ASP rule that is
%      associated with some action, the result of the action never changes, no matter how often the rule
%      fires.
%     \item transparent action execution, i.e. every action that is executed during evaluation of a program must be reflected in an answer set.

While the action semantics outlined so far addresses the requirements for both declarativity and functionality of actions outlined in the introduction (see \ref{goals:actions}), we haven't yet addressed the demand for transparency, i.e. that every action that is executed must be reflected in an aswer set of the respective program. With just the semantics outlined in Section \ref{subsec:evolog-actions-semantics}, it would be possible to write programs such as the one shown in Example \ref{ex:unsat-with-sideeffects} where an action rule can fire, but the program is unsatisfiable.

\begin{example}[Unsatisfiable Program with Side-effects]
\label{ex:unsat-with-sideeffects}
The program below contains an action rule that can fire (because $p(a)$ is true), but is also unsatisfiable due to the constraint in the last line.
\begin{align*}
	&p(a). \\
	&q(X) \leftarrow p(X). \\
	&act\_done(X, R) : @act(X) = R \leftarrow p(X). \\
	&\leftarrow q(X), act\_done(X, \_).
\end{align*}
\end{example}

This kind of programs raises some hard problems for implementations - given the contract that every side-effect of (i.e. action executed by) a program must be reported in an answer set, a solver evaluating the program from Example~\ref{ex:unsat-with-sideeffects} would have to "retract" action $act/1$ after finding that the program is unsatisfiable. Since it is generally not possible to "take back" side-effects (e.g. when some message is sent over a network broadcast to an unknown set of recipients), the only practical way to deal with this is to impose some conditions on programs with actions. Definition~\ref{def:evolog-actions-transparency} details this notion and introduces \emph{transparency} as a necessary condition for an Evolog program to be considered valid.

\begin{definition}[Action Transparency]
\label{def:evolog-actions-transparency}
An action rule $r_a$ of an Evolog program $P$ is \emph{transparent} if, for every expanded ground instance $gr_a$ it holds that, if $gr_a$ fires, then the head $h(gr_{a_{app}})$ of the repective application rule $gr_{a_{app}}$ is contained in an answer set of $P$. \\

For an Evolog program to be valid, all its action rules must be transparent.
\end{definition}

It follows from Definition \ref{def:evolog-actions-transparency} that only satisfiable programs can be transparent. Furthermore, note that Definition~\ref{def:evolog-actions-transparency} aims to be as permissive as possible in terms of program structure. In general, it can not be assumed that transparency of all rules in a program can be guaranteed up-front. Implementations may therefore impose further restrictions on what is considered a valid Evolog program. \todo{It might make sense to introduce the restriction P = CBP(P) for a valid program already here (anything more permissive cannot be linted without a theorem prover!)}


\section{Program Modularization in Evolog}
\label{sec:evolog-modules}

Modules aim to introduce a tool to \gls{asp} that helps with code reusability and testability.

Conceptually, an Evolog Module is a special kind of external atom (see~\ref{def:prelims-asp-syntax-ext-atom}) that refers to an ASP solver being called with some program and input.

\subsection{Syntax}

TODO The following design problems need solving:
\begin{itemize}
	\item If a complete answer set of a module is packed into one function term, how do you parse it (List iteration)? It probably makes the most sense to just inroduce list terms and be done with it...
	\item What's the best syntax to express whether we want just one, a certain number of, or all answer sets?
\end{itemize}

\begin{definition}[Module Literal]
A \emph{module literal} has the following form:
$$
	\rightarrow modname[i_1,\ldots,i_n]([o_1,\ldots,o_n]).
$$
\todo{maybe only use ">" as module signifier}
\end{definition}

\section{Relationship between Evolog- and Stable Model Semantics}

The extensions to the usual \gls{asp} programming language described in the previous sections extend the original formalism with a notion of an outside world (through frames in the context of which, actions can be expressed) as well as a grouping mechanism for sub-programs into modules.

\begin{theorem}[Extension]
\label{thm:extension}
Every ASP program $P$ is a valid and semantically equivalent Evolog program in the sense that - for any given frame $F$, the Evolog Models of $P$ are the same as its Answer Sets according to Stable Model Semantics~\ref{def:prelims-asp-semantics-answer-set}.
\end{theorem}

\begin{proof}
First, we assert that every "regular" ASP program P is also a syntactically valid Evolog program. This follows directly from the definitions - since Evolog only adds syntactic support for actions~\ref{def:action-rule-syntax}, but does not restrict regular ASP syntax, it follows that a syntactically correct ASP program is also a syntactically correct Evolog program. \\
Next, we show that for every regular ASP program $P$ and any frame $F$, the Evolog Models of $P$ are the same as its Stable Models, i.e. $\mathit{EM}(P)=\mathit{AS}(P)$: \\
Given any set of ground Atoms $A$ from the Herbrand Base $HB_P$ of $P$, $P$ is an Answer Set according to Stable Model Semantics if it is a minimal model of the GL-reduct~\ref{def:prelims-asp-semantics-gl-reduct} $P^{A}$ of $P$ w.r.t. $A$. We recall that $P^{A}$ is constructed as follows (see~\ref{def:prelims-asp-semantics-gl-reduct}):
\begin{itemize}
	\item remove from $P$ all rules $r$ that are "blocked", i.e. $A \not\models l$ for some literal $l \in b^{-}(r)$ 
	\item and remove the negative body of all other rules.
\end{itemize}
Furthermore, consider how the Evolog-Reduct of $P$ w.r.t. $A$ and (any arbitrary) Frame $F$, $P_{F}^{A}$, is constructed (see~\ref{def:evolog-reduct}):
\begin{itemize}
	\item Remove all rules $r$ from $P$ that are "blocked", i.e. $A \not\models l$ for some negative body literal $l \in b^{-}(r)$.
	\item Remove all action application rules from $P$ which are not supported by $F$.
	\item Remove the negative body from all other rules.
\end{itemize}
Since $P$ is a "regular", i.e. non-Evolog, ASP Program it contains no action application rules by definition. It is therefore clear, that for any set answer set candidate $A$ of $P$ and any Frame $F$, the GL-Reduct $P^{A}$ and Evolog-Reduct $P_{F}^{A}$ coincide. Any minimal model of the GL-reduct is therefore also a minimal model of the Evolog-Reduct (and vice-versa) and therefore the Evolog Models of P are identical with its Stable Models, i.e. $\mathit{EM}(P)=\mathit{AS}(P)$.
\end{proof}