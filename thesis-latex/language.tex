The Evolog language extends (non-disjunctive) ASP as defined in the ASP-Core2 standard~\cite{asp-core2} with facilities to communicate with and influence the "outside world" (e.g. read and write files, capture user input, etc.) as well as program modularization and reusability features, namely \emph{actions} and \emph{modules}.

\section{Actions in Evolog}
\label{sec:evolog-actions}

Actions allow for an ASP program to encode operations with \emph{side-effects} while maintaining fully declarative semantics. Actions are modelled in a functional style loosely based on the concept of monads as used in Haskell~\todo{cite something here!}. Intuitively, to maintain declarative semantics, actions need to behave as pure functions, meaning the result of executing an action (i.e. evaluating the respective function) must be reproducible for each input value across all executions. On first glance, this seems to contradict the nature of IO operations, which inherently depend on some state, e.g. the result of evaluating a function $getFileHandle(f)$ for a file $f$ will be different depending on whether $f$ exists, is readable, etc. However, at any given point in time - in other words, in a given state of the world - the operation will have exactly one result (i.e. a file handle or an error will be returned). A possible solution to making state-dependent operations behave as functions is therefore to make the state of the world at the time of evaluation part of the function's input. A function $f(x)$ is then turned into $f'(s, x)$  where $s$ represents a specific world state. The rest of this section deals with formalizing this notion of actions.

\todo{Define non-disjunctive ASP-Core2 in detail in preliminaires. Give detailed definition of all "standard ASP" elements referenced here!}

\subsection{Syntax}
\label{subsec:evolog-actions-syntax}

\begin{definition}[Action Rule, Action Program]
\label{def:action-rule-syntax}
An \emph{action rule} $R$ is of form
\[
	a_H : @t_{act} = act_{res} \leftarrow l_1,\ldots,l_n.
\]
where
\begin{itemize}
	\item $a_H$ is an atom called \emph{head atom},
	\item $t_{act}$ is a functional term called \emph{action term},
	\item $act_{res}$ is a term called \emph{(action-)result} term
	\item and $l_1,\ldots,l_n$ are literals constituting the \emph{body} of $R$.
\end{itemize}
An \emph{action program} $P$ is a set of (classic ASP-)rules and action rules.
\end{definition}

\subsection{Semantics}
\label{subsec:evolog-actions-semantics}

To properly define the semantics of an action program according to the intuition outlined at the start of this section, we first need to formalize our view of the "outside world" which action rules interact with. We call the world in which we execute a program a \emph{frame} - formally, action programs are always evaluated \emph{with respect to a given frame}. The behavior of actions is specified in terms of \emph{action functions}. The semantics (i.e. interpretations) of action functions in a program are defined by the respective frame.

\subsubsection{Action Rule Expansion}
\label{subsubsec:evolog-actions-semantics-expansion}

To get from the practical-minded action syntax from Definition~\ref{def:action-rule-syntax} to the formal representation of an action as a function of some state and an input, we use the helper construct of an action rule's \emph{expansion} to bridge the gap. Intuitively, the expansion of an action rule is a syntactic transformation that results in a more verbose version of the original rule called \emph{application rule} and a second rule only dependent on the application rule called \emph{projection rule}. A (ground) application rule's head atom uniquely identifies the ground instance of the rule that derived it. As one such atom corresponds to one action executed, we call a ground instance of an application rule head in an answer set an \emph{action witness}. 

\todo{define (classic ASP) grounding and substitutions in preliminaries}

\begin{definition}[Action Rule Expansion]
\label{def:action-rule-expansion}
Given a non-ground action rule $R$ with head atom $a_H$, action term $f_{act}(i_1,\ldots,i_n)$ and body  $B$ consisting of literals $l_1,\ldots,l_m$, the expansion of $R$ is a pair of rules consisting of an \emph{application rule} $R_{app}$ and \emph{projection rule} $R_{proj}$. $R_{app}$ is defined as
\[
	a_{res}(f_{act}, S, I, f_{act}(S, I)) \leftarrow l_1,\ldots,l_n.
\]
where $S$ and $I$ and function terms called \emph{state-} and \emph{input-}terms, respectively.
An action rule's state term has the function symbol $\mathit{state}$ and terms $fn(l_1),\ldots,fn(l_m)$, with the expression $fn(l)$ for a literal $l$ denoting a function term representing $l$. The (function-)term representation of a literal $p(t_1,\ldots,t_n)$ with predicate symbol $p$ and terms $t_1,\ldots,t_n$ uses $p$ as function symbol. For a negated literal $\mathit{not}~p(t_1,\ldots,t_n)$, the representing function term is $not(p(t_1,\ldots,p_n))$. The action input term is a "wrapped" version of all arguments of the action term, i.e. for action term $f_{act}(t_1,\ldots,t_n)$, the corresponding input term is $input(t_1,\ldots,t_n)$. The term $f_{act}(S, I)$ is called \emph{action application term}. \\
The projection rule $R_{proj}$ is defined as
\[
	a_H \leftarrow a_{res}(f_{act}, S, I, v_{res}).
\]
where $a_H$ is the head atom of the initial action rule $R$ and the (sole) body atom is the action witness derived by $R_{app}$, with the application term $f_{act}(S, I)$ replaced by a variable $v_{res}$ called \emph{action result variable}.
\end{definition}

Looking at the head of an action application rule of format $a_{res}(f_{act}, S, I, \mathit{t_{app}})$ with action $f_{act}$, state term $S$, input term $I$ and application term $t_{app}$, the intuitive reading of this atom is "The result of action function $f_{act}$ applied to state $S$ and input $I$ is $t_{app}$", i.e. the action application term $t_{app}$ is not a regular (uninterpreted) function term as in regular ASP, but an actual function call which is resolved using an interpretation function provided by a \emph{frame} during grounding.

%% NOTE: Action func. term is uninterpreted in nonground view! Application formally happens during grounding, i.e. action fnc is applied in grounding, ground version has action result.

%% TODO define grounding with respect to a frame - grounding eliminates action terms, i.e. action functions are applied during grounding!

\subsubsection{Grounding of Action Rules}
\label{subsubsec:evolog-actions-semantics-grounding}

Grounding, in the context of answer set programming, generally refers to the conversion of a program with variables into a semantically equivalent, variable-free, version. Action application terms as introduced in Definition \ref{def:action-rule-expansion} can be intuitively read as variables, in the sense that they represent the result of applying the respective action function. Consequently, all action application terms are replaced with the respective (ground) result terms defined in the \emph{frame} with respect to which the program is grounded.

\begin{definition}[Frame]
\label{def:evolog-frame}
Given an action program $P$ containing action application terms $A = \{a_1,\ldots,a_n\}$, a frame $F$ is an interpretation function such that, for each application term $f_{act}(S, I) \in A$ where $S \in H_{U}(P)^{*}$ and $I \in H_{U}(P)^{*}$, $F(f_{act}): H_{U}(P)^{*} \times H_{U}(P)^{*} \mapsto H_{U}(P)$.
\end{definition}

Example \ref{ex:action-rule-expansion} demonstrates the expansion of an action rule as well as a compatible example frame for the respective action.

\begin{example}[Expansion and Frame]
\label{ex:action-rule-expansion}
Consider following Evolog Program $P$ which contains an action rule with action $a$:
\begin{align*}
	&p(a).~q(b).~r(c). \\
	&h(X, R) : @a(X, Z) = R \leftarrow p(X), q(Y), r(Z).
\end{align*}
The expansion of $R$ is:
\begin{align*}
	a_{res}(a, \mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z), a(\mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z))) \leftarrow& \\
	p(X), q(Y), r(Z).& \\
	h(X, R) \leftarrow a_{res}(a, \mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z), R).&
\end{align*}
Furthermore, consider following frame $F$:
\[
	F(a) = \{a(\mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c))) \mapsto \mathit{success}(a, c)\}
\]
which assigns the result $\mathit{success}(a, c)$ to the action application term (i.e. function call $a(\mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c)))$. \\

Then, the ground program $P_{grnd}$ after action rule expansion is
\begin{align*}
	p(a).~q(b).~r(c).& \\
	a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c)) \leftarrow p(a).~q(b).~r(c).& \\
	h(a, \mathit{success}(a, c)) \leftarrow a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c)).&
\end{align*}
The sole model of $P$ with respect to frame $F$ is \todo{according to which semantics? reference LFP here}
\begin{align*}
	M = \{p(a), q(b), r(c),& \\
	a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c))& \\ h(a, \mathit{success}(a, c))\}&
\end{align*}
\end{example}