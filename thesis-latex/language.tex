The Evolog language extends (non-disjunctive) ASP as defined in the ASP-Core2 standard~\cite{asp-core2} with facilities to communicate with and influence the "outside world" (e.g. read and write files, capture user input, etc.) as well as program modularization and reusability features, namely \emph{actions} and \emph{modules}.

\section{Actions in Evolog}
\label{sec:evolog-actions}

Actions allow for an ASP program to encode operations with \emph{side-effects} while maintaining fully declarative semantics. Actions are modelled in a functional style loosely based on the concept of monads as used in Haskell~\todo{cite something here!}. Intuitively, to maintain declarative semantics, actions need to behave as pure functions, meaning the result of executing an action (i.e. evaluating the respective function) must be reproducible for each input value across all executions. On first glance, this seems to contradict the nature of IO operations, which inherently depend on some state, e.g. the result of evaluating a function $getFileHandle(f)$ for a file $f$ will be different depending on whether $f$ exists, is readable, etc. However, at any given point in time - in other words, in a given state of the world - the operation will have exactly one result (i.e. a file handle or an error will be returned). A possible solution to making state-dependent operations behave as functions is therefore to make the state of the world at the time of evaluation part of the function's input. A function $f(x)$ is then turned into $f'(s, x)$  where $s$ represents a specific world state. The rest of this section deals with formalizing this notion of actions.

\todo{Define non-disjunctive ASP-Core2 in detail in preliminaries. Give detailed definition of all "standard ASP" elements referenced here!}

\subsection{Syntax}
\label{subsec:evolog-actions-syntax}

\begin{definition}[Action Rule, Action Program]
\label{def:action-rule-syntax}
An \emph{action rule} $R$ is of form
\[
	a_H : @t_{act} = act_{res} \leftarrow l_1,\ldots,l_n.
\]
where
\begin{itemize}
	\item $a_H$ is an atom called \emph{head atom},
	\item $t_{act}$ is a functional term called \emph{action term},
	\item $act_{res}$ is a term called \emph{(action-)result} term
	\item and $l_1,\ldots,l_n$ are literals constituting the \emph{body} of $R$.
\end{itemize}
An \emph{action program} $P$ is a set of (classic ASP-)rules and action rules.
\end{definition}

\subsection{Semantics}
\label{subsec:evolog-actions-semantics}

To properly define the semantics of an action program according to the intuition outlined at the start of this section, we first need to formalize our view of the "outside world" which action rules interact with. We call the world in which we execute a program a \emph{frame} - formally, action programs are always evaluated \emph{with respect to a given frame}. The behavior of actions is specified in terms of \emph{action functions}. The semantics (i.e. interpretations) of action functions in a program are defined by the respective frame.

\subsubsection{Action Rule Expansion}
\label{subsubsec:evolog-actions-semantics-expansion}

To get from the practical-minded action syntax from Definition~\ref{def:action-rule-syntax} to the formal representation of an action as a function of some state and an input, we use the helper construct of an action rule's \emph{expansion} to bridge the gap. Intuitively, the expansion of an action rule is a syntactic transformation that results in a more verbose version of the original rule called \emph{application rule} and a second rule only dependent on the application rule called \emph{projection rule}. A (ground) application rule's head atom uniquely identifies the ground instance of the rule that derived it. As one such atom corresponds to one action executed, we call a ground instance of an application rule head in an answer set an \emph{action witness}. 

\todo{define (classic ASP) grounding and substitutions in preliminaries}

\begin{definition}[Action Rule Expansion]
\label{def:action-rule-expansion}
Given a non-ground action rule $R$ with head atom $a_H$, action term $f_{act}(i_1,\ldots,i_n)$ and body  $B$ consisting of literals $l_1,\ldots,l_m$, the expansion of $R$ is a pair of rules consisting of an \emph{application rule} $R_{app}$ and \emph{projection rule} $R_{proj}$. $R_{app}$ is defined as
\[
	a_{res}(f_{act}, S, I, f_{act}(S, I)) \leftarrow l_1,\ldots,l_n.
\]
where $S$ and $I$ and function terms called \emph{state-} and \emph{input-}terms, respectively.
An action rule's state term has the function symbol $\mathit{state}$ and terms $fn(l_1),\ldots,fn(l_m)$, with the expression $fn(l)$ for a literal $l$ denoting a function term representing $l$. The (function-)term representation of a literal $p(t_1,\ldots,t_n)$ with predicate symbol $p$ and terms $t_1,\ldots,t_n$ uses $p$ as function symbol. For a negated literal $\mathit{not}~p(t_1,\ldots,t_n)$, the representing function term is $not(p(t_1,\ldots,p_n))$. The action input term is a "wrapped" version of all arguments of the action term, i.e. for action term $f_{act}(t_1,\ldots,t_n)$, the corresponding input term is $input(t_1,\ldots,t_n)$. The term $f_{act}(S, I)$ is called \emph{action application term}. \\
The projection rule $R_{proj}$ is defined as
\[
	a_H \leftarrow a_{res}(f_{act}, S, I, v_{res}).
\]
where $a_H$ is the head atom of the initial action rule $R$ and the (sole) body atom is the action witness derived by $R_{app}$, with the application term $f_{act}(S, I)$ replaced by a variable $v_{res}$ called \emph{action result variable}.
\end{definition}

Looking at the head of an action application rule of format $a_{res}(f_{act}, S, I, \mathit{t_{app}})$ with action $f_{act}$, state term $S$, input term $I$ and application term $t_{app}$, the intuitive reading of this atom is "The result of action function $f_{act}$ applied to state $S$ and input $I$ is $t_{app}$", i.e. the action application term $t_{app}$ is not a regular (uninterpreted) function term as in regular ASP, but an actual function call which is resolved using an interpretation function provided by a \emph{frame} during grounding.

%% NOTE: Action func. term is uninterpreted in nonground view! Application formally happens during grounding, i.e. action func is applied in grounding, ground version has action result.

\subsubsection{Grounding of Action Rules}
\label{subsubsec:evolog-actions-semantics-grounding}

Grounding, in the context of answer set programming, generally refers to the conversion of a program with variables into a semantically equivalent, variable-free, version. Action application terms as introduced in Definition \ref{def:action-rule-expansion} can be intuitively read as variables, in the sense that they represent the result of applying the respective action function. Consequently, all action application terms are replaced with the respective (ground) result terms defined in the \emph{frame} with respect to which the program is grounded.

\begin{definition}[Frame]
\label{def:evolog-frame}
Given an action program $P$ containing action application terms $A = \{a_1,\ldots,a_n\}$, a frame $F$ is an interpretation function such that, for each application term $f_{act}(S, I) \in A$ where $S \in H_{U}(P)^{*}$ and $I \in H_{U}(P)^{*}$, $F(f_{act}): H_{U}(P)^{*} \times H_{U}(P)^{*} \mapsto H_{U}(P)$.
\end{definition}

\begin{definition}[Grounding of action rules]
\label{def:evolog-grounding}
Grounding of Evolog rules (and programs) always happens \emph{with respect to a frame}. Given a frame $F$, an expanded action rule $r_a$ and a (grounding) substitution $\sigma$ over all body variables of application rule $r_{a_{app}}$, during grounding, every ground action application term $t_{app}\sigma$ resulting from applying substitution $\sigma$ is replaced with its interpretation according to $F$.
\end{definition}

Example \ref{ex:action-rule-expansion} demonstrates the expansion of an action rule as well as a compatible example frame for the respective action.

\begin{example}[Expansion and Frame]
\label{ex:action-rule-expansion}
Consider following Evolog Program $P$ which contains an action rule with action $a$:
\begin{align*}
	&p(a).~q(b).~r(c). \\
	&h(X, R) : @a(X, Z) = R \leftarrow p(X), q(Y), r(Z).
\end{align*}
The expansion of $R$ is:
\begin{align*}
	a_{res}(a, \mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z), a(\mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z))) \leftarrow& \\
	p(X), q(Y), r(Z).& \\
	h(X, R) \leftarrow a_{res}(a, \mathit{state}(p(X), q(Y), r(Z)), \mathit{input}(X, Z), R).&
\end{align*}
Furthermore, consider following frame $F$:
\[
	F(a) = \{a(\mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c)) \mapsto \mathit{success}(a, c)\}
\]
which assigns the result $\mathit{success}(a, c)$ to the action application term (i.e. function call $a(\mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c)))$. \\

Then, the ground program $P_{grnd}$ after action rule expansion is
\begin{align*}
	p(a).~q(b).~r(c).& \\
	a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c)) \leftarrow p(a).~q(b).~r(c).& \\
	h(a, \mathit{success}(a, c)) \leftarrow a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c)).&
\end{align*}
The sole model of $P$ with respect to frame $F$ is 
\begin{align*}
	M = \{p(a), q(b), r(c),& \\
	a_{res}(a, \mathit{state}(p(a), q(b), r(c)), \mathit{input}(a, c), \mathit{success}(a, c))& \\ h(a, \mathit{success}(a, c))\}&
\end{align*}
\end{example}

\subsubsection{Evolog Models}
\label{subsubsec:evolog-action-semantics-models}

Having introduced action rule expansions as well as frames, we now use these to extend the stable model semantics to Evolog programs.

\begin{definition}[Supportedness of Actions]
\label{def:evolog-supported-action}
Let $r_{app}$ be a non-ground action application rule with head $H = a_{res}(f_{act}, S, I, f_{act}(S, I))$, $F$ a frame, and $H_{grnd} = a_{res}(f_{act}, S_{grnd}, I_{grnd}, r)$ a ground instance of $H$ with $r$ being an arbitrary ground term.
Then, $H_{grnd}$ is \emph{supported by $F$}, if and only if $F$ contains a mapping of form $f_{act}(S_{grnd}, I_{grnd}) \mapsto r$, i.e. $r$ is a valid result of action function $f_{act}$ with arguments $S_{grnd}$ and $I_{grnd}$ according to frame $F$. 
We call a ground instance of an action rule \emph{supported by a frame} if the head of the corresponding application rule in the rule's expansion is supported by that frame.
\end{definition}

\begin{definition}[Evolog-Reduct]
\label{def:evolog-reduct}
Given a ground Evolog program $P$, a frame $F$ and a set of ground atoms $A$, the \emph{Evolog Reduct} of $P$ with respect to $F$ and $A$ $P_{F}^{A}$ is obtained from $P$ as follows:
\begin{enumerate}
	\item Remove all rules $r$ from $P$ that are "blocked", i.e. $A \not\models l$ for some negative body literal $l \in b^{-}(r)$.
	\item Remove all action application rules from $P$ which are not supported by $F$.
	\item Remove the negative body from all other rules.
\end{enumerate}
\end{definition}

Note that the reduct outlined in Definition \ref{def:evolog-reduct} extends the classic GL-reduct (see Definition \ref{def:prelims-asp-semantics-gl-reduct}) just by adding a check on action supportedness.

\begin{definition}[Evolog Model]
A herbrand interpretation $I$ of an Evolog Program is an \emph{Evolog Model} ("answer set") of an Evolog program $P$ with respect to a frame $F$ if and only if it is a minimal classical model of its Evolog-Reduct $P_{F}^{A}$. We denote the set of Evolog Models of a program $P$ as $\mathit{EM}(P)$.
\end{definition}

\subsection{Restrictions on Program Structure}

As has been stated at the start of this section, actions in Evolog aim to add a declarative way of interacting with the outside world to \gls{asp}. The central contract action rules need to fulfill is that, given a ground action (application-)rule and some fixed state of the outside world, 



\section{Program Modularization in Evolog}
\label{sec:evolog-modules}

TODO

\section{Relationship between Evolog- and Stable Model Semantics}

The extensions to the usual \gls{asp} programming language described in the previous sections extend the original formalism with a notion of an outside world (through frames in the context of which, actions can be expressed) as well as a grouping mechanism for sub-programs into modules.

\begin{theorem}[Extension]
\label{thm:extension}
Every ASP program $P$ is a valid and semantically equivalent Evolog program in the sense that - for any given frame $F$, the Evolog Models of $P$ are the same as its Answer Sets according to Stable Model Semantics~\ref{def:prelims-asp-semantics-answer-set}.
\end{theorem}

\begin{proof}
First, we assert that every "regular" ASP program P is also a syntactically valid Evolog program. This follows directly from the definitions - since Evolog only adds syntactic support for actions~\ref{def:action-rule-syntax}, but does not restrict regular ASP syntax, it follows that a syntactically correct ASP program is also a syntactically correct Evolog program. \\
Next, we show that for every regular ASP program $P$ and any frame $F$, the Evolog Models of $P$ are the same as its Stable Models, i.e. $\mathit{EM}(P)=\mathit{AS}(P)$: \\
Given any set of ground Atoms $A$ from the Herbrand Base $HB_P$ of $P$, $P$ is an Answer Set according to Stable Model Semantics if it is a minimal model of the GL-reduct~\ref{def:prelims-asp-semantics-gl-reduct} $P^{A}$ of $P$ w.r.t. $A$. We recall that $P^{A}$ is constructed as follows (see~\ref{def:prelims-asp-semantics-gl-reduct}):
\begin{itemize}
	\item remove from $P$ all rules $r$ that are "blocked", i.e. $A \not\models l$ for some literal $l \in b^{-}(r)$ 
	\item and remove the negative body of all other rules.
\end{itemize}
Furthermore, consider how the Evolog-Reduct of $P$ w.r.t. $A$ and (any arbitrary) Frame $F$, $P_{F}^{A}$, is constructed (see~\ref{def:evolog-reduct}):
\begin{itemize}
	\item Remove all rules $r$ from $P$ that are "blocked", i.e. $A \not\models l$ for some negative body literal $l \in b^{-}(r)$.
	\item Remove all action application rules from $P$ which are not supported by $F$.
	\item Remove the negative body from all other rules.
\end{itemize}
Since $P$ is a "regular", i.e. non-Evolog, ASP Program it contains no action application rules by definition. It is therefore clear, that for any set answer set candidate $A$ of $P$ and any Frame $F$, the GL-Reduct $P^{A}$ and Evolog-Reduct $P_{F}^{A}$ coincide. Any minimal model of the GL-reduct is therefore also a minimal model of the Evolog-Reduct (and vice-versa) and therefore the Evolog Models of P are identical with its Satble Models, i.e. $\mathit{EM}(P)=\mathit{AS}(P)$.
\end{proof}