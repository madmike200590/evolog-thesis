In this chapter, we apply Alpha's Evolog extension to a larger example. In order to showcase the kind of applications that can be written in pure Evolog (without the need to resort to any additional programming language), we implement an application that:
\begin{itemize}
    \item asks the user to enter a path to a file containing a graph represented in XML format,
    \item reads and parses the XML content of the given files,
    \item calculates 3-colorings of the graph from the XML file,
    \item and finally writes the list of obtained colorings to a user-supplied file path.
\end{itemize}    

We first describe the program itself and then move on to a discussion of observations that can be made from the example.

\section{Interactive XML-based Graph Coloring}
\label{sec:results-xml-graphcol}

TODO: Reference full program in appendix. Maybe lose a few words about overall structure again.

\subsection{Reading files from user-supplied paths}

First, the user is asked to enter a file path. The content of the given file is then read line-by-line and aggregateed into a list term. Listing~\ref{lst:results-xml-graphcol-userinput} shows this part of the program.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-graphcol-userinput}, caption={Reading a file based on user input.}] 
enter_input_prompt("Please enter a path to read graphs from: ").

write_input_prompt_res(R) : @streamWrite[STDOUT, PROMPT] = R :- 
    enter_input_prompt(PROMPT), &stdout(STDOUT).
usr_input_res(INP) : @streamReadLine[STDIN] = INP :- 
    write_input_prompt_res(success(_)), &stdin(STDIN).

infile(PATH) :- usr_input_res(success(line(PATH))).
infile_open(PATH, HD) : @fileInputStream[PATH] = HD :- 
    infile(PATH).

% Handle file opening error
error(io, MSG) :- infile_open(_, error(MSG)).

% Read all lines from infile 
readline_result(PATH, 0, RES) : 
    @streamReadLine[STREAM] = RES :- 
    infile(PATH), infile_open(PATH, success(stream(STREAM))).
readline_result(PATH, LINE_NO, RES) : 
    @streamReadLine[STREAM] = RES :- 
    infile(PATH), 
    infile_open(PATH, success(stream(STREAM))), 
    readline_result(PATH, PREV_LINE_NO, PREV_LINE_RES), 
    PREV_LINE_RES != success(line(eof)), 
    LINE_NO = PREV_LINE_NO + 1.

% close stream after getting eof
infile_closed(PATH, RES) : 
    @inputStreamClose[STREAM] = RES :- 
    infile(PATH), 
    infile_open(PATH, success(stream(STREAM))),
    readline_result(PATH, _, ok(eof)).

% Now create a list of content lines
file_lines(PATH, LST) :- 
    LST = #list{ 
        line(LINE_NO, LINE) : 
            readline_result(PATH, LINE_NO, success(line(LINE))), 
            LINE != eof },
    infile(PATH). 
\end{lstlisting}    

The rule on line 3 derives the predicate \texttt{write\_input\_prompt\_res/1}, which wraps the result of a stream output operation - which in this case writes a prompt text to stdout. Note that the \emph{standard output stream} \texttt{STDOUT} does not need to be opened using an Evolog action, but is always available to an application. A reference to \texttt{STDOUT} can be obtained through the external atom \texttt{stdout/1}.

If writing the prompt text succeeds, i.e. in case the result term of the write action has structure \texttt{success(\_)}, user input is read from the \emph{standard input stream} \texttt{STDIN}. The result of the read operation is derived on line 5 using  predicate \texttt{usr\_input\_res/1}. Note that, as with stdout, \texttt{STDIN} does not have to be opened, but is obtained using the external atom \texttt{stdin/1}.

In case the read operation succeeded, we attempt to open an input stream on the file entered by the user. The rule on line 9 derives the result of this operation in the \texttt{infile\_open/2} predicate. The first term is the path of the respective file, the second is an action result term which either takes the form \texttt{error(MSG)} or holds a reference to a file input stream \texttt{STREAM} wrapped in a function term \texttt{success(stream(STREAM))}.

If opening succeeds, the openend file is read line-wise, using the rules on lines 16 and 19. Lines are numbered in order to keep positional information of file content. Reading stops once the result from the last \texttt{@streamReadLine} action is \texttt{success(line(eof))} where \texttt{eof} denotes \emph{end-of-file}.

After all lines of the input file have been read successfully an \texttt{@inputStreamClose} action is used to close the input file (see line 28). Finally, all lines from a file are aggregated into a single list term using a \texttt{\#list} aggregate in the rule on line 35.

\subsection{Parsing XML data}
\label{subsec:results-xml-parsing}

Based on the list of lines in an input file, the contained XML data is parsed using a separate Evolog Module \texttt{xml\_dom}, which is described in more detail in Section~\ref{subsec:results-xml-parsing-details}. Input files are expected to conform to the \gls{dtd} in Listing\ref{lst:results-xml-graphcol-input}.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-graphcol-input}, caption={\gls{dtd} for graph XML files.}]  
<!ELEMENT graph (vertices, edges)>
<!ATTLIST graph directed (true | false) #REQUIRED>

<!ELEMENT vertices (vertex+)>
<!ELEMENT vertex (#PCDATA)>

<!ELEMENT edges (edge+)>
<!ELEMENT edge (source, target)>
<!ELEMENT source (#PCDATA)>
<!ELEMENT target (#PCDATA)>    
\end{lstlisting}    

Listing~\ref{lst:results-xml-graphcol-input-ex} shows an example input file conforming to the \gls{dtd} which describes the complete graph $K_3$.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-graphcol-input-ex}, caption={The complete graph $K_3$ represented according to the \gls{dtd} from Listing~\ref{lst:results-xml-graphcol-input}.}]
<graph directed="false">
    <vertices>
        <vertex>a</vertex>
        <vertex>b</vertex>
        <vertex>c</vertex>
    </vertices>
    <edges>
        <edge>
            <source>a</source>
            <target>b</target>
        </edge>
        <edge>
            <source>b</source>
            <target>c</target>
        </edge>
        <edge>
            <source>c</source>
            <target>a</target>
        </edge>
    </edges>    
</graph>
\end{lstlisting} 

The XML-parsing module has 4 output terms which represent lists of \gls{dom} elements, parent-child relationships between \gls{dom} elements, text content of elements as well as attributes, respectively. Listing~\ref{lst:results-xml-graphcol-dom-unpack} shows the Evolog code to parse the XML content of an input file. Since each of the four result terms of the \texttt{xml\_dom} module is a list term, in order to have one atom per list entry, each list needs to be "unwrapped". List terms are unwrapped by first deriving one "entry"-atom for every element of the list which holds the element itself along with all successor elements in the list (i.e. the "tail list"). Finally, the tail list of each entry atom is projected away using an additional rule, such that tehre is one atom for each element of the original list. In Listing~\ref{lst:results-xml-graphcol-dom-unpack}, this unwrapping is performed for each output list of the XML parsing module from line 8 onward.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-graphcol-dom-unpack}, caption={Parsing and consuming XML data in an Evolog program.}]
% Parse the string content of individual lines into a 
% DOM-like representation
file_dom(PATH, dom(ELEMENTS, CHILDREN, TEXTS, ATTRIBUTES)) :- 
    file_lines(PATH, LINES), 
    #xml_dom[LINES](ELEMENTS, CHILDREN, TEXTS, ATTRIBUTES).

% Unwrap list elements from module output
dom_element_entry(NAME, ID, TAIL) :- 
    file_dom(_, dom(lst(dom_element(NAME, ID), TAIL), _, _, _)).
dom_element_entry(NAME, ID, TAIL) :- 
    dom_element_entry(_, _, lst(dom_element(NAME, ID), TAIL)).
dom_element(NAME, ID) :- 
    dom_element_entry(NAME, ID, _).

dom_element_child_entry(NAME, ID, CHILD_ID, TAIL) :- 
    file_dom(_,dom(_, lst(
        dom_element_child(NAME, ID, CHILD_ID), TAIL), _, _)).
dom_element_child_entry(NAME, ID, CHILD_ID, TAIL) :- 
    dom_element_child_entry(_, _, _, lst(
        dom_element_child(NAME, ID,CHILD_ID), TAIL)).
dom_element_child(NAME, ID, CHILD_ID) :- 
    dom_element_child_entry(NAME, ID, CHILD_ID, _).

dom_element_text_entry(NAME, ID, TEXT, TAIL) :- 
    file_dom(_,dom(_, _, lst
    (dom_element_text(NAME, ID, TEXT), TAIL), _)).
dom_element_text_entry(NAME, ID, TEXT, TAIL) :- 
    dom_element_text_entry(_, _, _, lst(
        dom_element_text(NAME, ID, TEXT), TAIL)).
dom_element_text(NAME, ID, TEXT) :- 
    dom_element_text_entry(NAME, ID, TEXT, _).

dom_element_attribute_entry(
    NAME, ID, ATTR_NAME, ATTR_VALUE, TAIL) :- 
    file_dom(_,dom(_, _, _, lst(
        dom_element_attribute(
            NAME,ID, ATTR_NAME, ATTR_VALUE), TAIL))).
dom_element_attribute_entry(
    NAME, ID, ATTR_NAME, ATTR_VALUE, TAIL) :- 
    dom_element_attribute_entry(_, _, _, lst(
        dom_element_attribute(
            NAME, ID, ATTR_NAME, ATTR_VALUE), TAIL)).
dom_element_attribute(NAME, ID, ATTR_NAME, ATTR_VALUE) :- 
    dom_element_attribute_entry(
        NAME, ID, ATTR_NAME, ATTR_VALUE, _).   
\end{lstlisting}  

\subsection{An XML-DOM parser in ASP}
\label{subsec:results-xml-parsing-details}

The module \texttt{xml\_dom} which is used in Listing~\ref{lst:results-xml-graphcol-dom-unpack} implements a generic XML-parser that generates a DOM-representation based on external atoms for regex evaluation.

Input is encoded as a list of strings, each one representing a line of input. At first, all input is tokenized in order to find opening and closing XML tags. Listing~\ref{lst:results-xml-parse-tokenize} shows the Evolog code used for tokenization in the \texttt{xml\_dom} module.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-parse-tokenize}, caption={Tokenizing XML input.}]
token_regex(tag_open, "(<(\w+)( (\w+=\\"\w+\\"))*>)").
token_regex(tag_close, "(</\w+>)").
opening_tag_name_regex("<(\w+)( (\w+=\\"\w+\\"))*>").
closing_tag_name_regex("</(\w+)>").
attribute_regex("(\w+=\\"\w+\\")").
attribute_name_regex("(\w+)=\\"\w+\\"").
attribute_value_regex("\w+=\\"(\w+)\\"").

% Unwrap lines
line_element(E, TAIL) :- input_lines(lst(E, TAIL)).
line_element(E, TAIL) :- line_element(_, lst(E, TAIL)).
line(LINE_NO, LINE) :- line_element(line(LINE_NO, LINE), _).

% Match basic tokens
token(t(TOK, VALUE), LINE_NO, FROM, TO) :- 
    line(LINE_NO, LINE), token_regex(TOK, REGEX), 
    &regex_matches[REGEX, LINE](VALUE,FROM, TO). 
\end{lstlisting}

Regular expressions to match opening and closing XML tags are represented as facts the predicate \texttt{token\_regex/2}. The external atom \texttt{regex\_matches/5} is used to determine whether a line matches a token regex, as well as the respective parts of the string where the match occurs.

Once all tokens denoting opening and closing tags - up until that point ignoring actual tag names and relative positions of tags to each other - the next step is extracting actual tag names and pairs of opening and closing tags of the same name. This part of the parsing process is demonstrated in Listing~\ref{lst:results-xml-parse-tag-pairs}. First, a relative ordering of tokens is established using the \texttt{token\_before/8} predicate, which is derived by the rules on lines 2 through 11. Furthermore, we extract the name of each tag by using a variant of the tag open/close regexes with capture groups such that the first group is only the actual name of the tag, see lines 14 to 29. A matching pair of opening and closing tags in a well-formed XML document is characterized as an opening and a closing tag of the same name, with no opening tag of that name in between. In order to find these pairs, we first derive all matching pairs which do have another opening tag between them as instances of predicate \texttt{tag\_opening\_between/7}. The actual tag pairs making up well-formed XML elements are the derived using the rule on line 54 as those pairs of matching tags for which no corresponding instance of \texttt{tag\_opening\_between/7} exists.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-parse-tag-pairs}, caption={Finding pairs of matching opening and closing XML tags.}]
% Establish a token ordering
token_before(TOK1, TOK1_LINE_NO, TOK1_FROM, TOK1_TO, 
        TOK2, TOK2_LINE_NO, TOK2_FROM, TOK2_TO) :- 
	token(TOK1, TOK1_LINE_NO, TOK1_FROM, TOK1_TO), 
	token(TOK2, TOK2_LINE_NO, TOK2_FROM, TOK2_TO), 
	TOK1_LINE_NO = TOK2_LINE_NO, TOK1_TO < TOK2_FROM.
token_before(TOK1, TOK1_LINE_NO, TOK1_FROM, TOK1_TO, 
        TOK2, TOK2_LINE_NO, TOK2_FROM, TOK2_TO) :- 
	token(TOK1, TOK1_LINE_NO, TOK1_FROM, TOK1_TO), 
	token(TOK2, TOK2_LINE_NO, TOK2_FROM, TOK2_TO), 
	TOK1_LINE_NO < TOK2_LINE_NO.

% Extract tag names
tag_opening(TAG_NAME, t(tag_open, TOK_VALUE), 
        LINE_NO, TAG_FROM, TAG_TO) :- 
	token(
            t(tag_open, TOK_VALUE), 
            LINE_NO, TAG_FROM, TAG_TO),
	&regex_matches
        [TAG_NAME_REGEX, TOK_VALUE](TAG_NAME, _, _),
	opening_tag_name_regex(TAG_NAME_REGEX).
tag_closing(TAG_NAME, t(tag_close, TOK_VALUE), 
        LINE_NO, TAG_FROM, TAG_TO) :- 
	token(
            t(tag_close, TOK_VALUE), 
            LINE_NO, TAG_FROM, TAG_TO),
	&regex_matches
        [TAG_NAME_REGEX, TOK_VALUE](TAG_NAME, _, _),
	closing_tag_name_regex(TAG_NAME_REGEX).

% We have an opening/closing tag pair if tag name is the same, 
% opening tag is before closing tag, 
% and no opening tag of same name between.
tag_opening_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, 
        CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO) :- 
	tag_opening(TAG_NAME, OPEN_TOK, 
        OPEN_LINE_NO, OPEN_FROM, OPEN_TO),
	tag_closing(TAG_NAME, CLOSE_TOK, 
        CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO),
	token(CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token(INTM_OPEN_TOK, INTM_OPEN_LINE_NO, 
        INTM_OPEN_FROM, INTM_OPEN_TO),
	tag_opening(TAG_NAME, INTM_OPEN_TOK, 
        INTM_OPEN_LINE_NO, INTM_OPEN_FROM, INTM_OPEN_TO),
	token_before(
        OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, 
        INTM_OPEN_TOK, INTM_OPEN_LINE_NO, 
        INTM_OPEN_FROM, INTM_OPEN_TO),
	token_before(
        INTM_OPEN_TOK, INTM_OPEN_LINE_NO, INTM_OPEN_FROM, 
        INTM_OPEN_TO, CLOSE_TOK, CLOSE_LINE_NO, 
        CLOSE_FROM, CLOSE_TO).
element(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, 
        CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO) :- 
	tag_opening(TAG_NAME, OPEN_TOK, 
        OPEN_LINE_NO, OPEN_FROM, OPEN_TO),
	tag_closing(TAG_NAME, CLOSE_TOK, 
        CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO),
	token(CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token_before(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, 
        CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	not tag_opening_between(
        TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, 
        CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO).
\end{lstlisting}    

Having parsed all XML elements, the next step is to determine which of these are terminal elements in the sense that they only contain text, as opposed to elements which consist of further XML elements. This is achieved using the code form Listing~\ref{lst:results-xml-parse-element-types}.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-parse-element-types}, caption={Parsing details of XML elements}]
% Any string between two tags with no other opening 
% or closing tags between is content
any_tag_opening_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO) :- 
	element(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO),
	token(CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token_before(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, t(tag_open, INTM_TOK), INTM_LINE_NO, INTM_FROM, INTM_TO),
	token_before(t(tag_open, INTM_TOK), INTM_LINE_NO, INTM_FROM, INTM_TO, CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO).
any_tag_closing_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO) :- 
	element(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO),
	token(CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	token_before(OPEN_TOK, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, t(tag_close, INTM_TOK), INTM_LINE_NO, INTM_FROM, INTM_TO),
	token_before(t(tag_close, INTM_TOK), INTM_LINE_NO, INTM_FROM, INTM_TO, CLOSE_TOK, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO). 
any_tag_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO) :-
	any_tag_opening_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	any_tag_closing_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO).       
terminal(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO) :- 
	element(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	not any_tag_between(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO).
% Extract content between tags (currently assumes start and end tags to be on the same line)
element_text(ELEMENT_NAME, FROM_POS, TO_POS, TEXT) :-
	terminal(ELEMENT_NAME, LINE_NO, OPEN_FROM, OPEN_TO, LINE_NO, CLOSE_FROM, CLOSE_TO),
	line(LINE_NO, FULL_LINE),
	&string_substring[FULL_LINE, OPEN_TO, CLOSE_FROM](TEXT),
	FROM_POS = pos(LINE_NO, OPEN_FROM),
	TO_POS = pos(LINE_NO, CLOSE_TO).
\end{lstlisting} 

In Listing~\ref{lst:results-xml-parse-element-types}, the rule on line 18 derives whether an XML element is a \emph{terminal} element in that is does not enclose any additional elements other than plain text. In order to determine this, we check if there are any opening or closing tags between the opening and closing tags of the element in question, see lines 3 through 15. For all terminal elements, we parse the text content of each individual element by taking a substring of the line containing the opening and closing tags ranging from after the last character of the opening tag to before the first character of the closing tag. (Note that this implementation assumes that content within a tag does not contain newline characters in order to keep the code a bit shorter.)

Every XML tag can also have any number of attributes. The parsing logic for attributes is shown in Listing~\ref{lst:results-xml-parse-attributes}. First, attributes are detected by checking every string that has been matched to be an opening XML tag against regular expressions matching attribute name an values, see the rule on line 2. Attributes derived using this approach are then associated with the corresponding \texttt{element/7} instance through the predicate \texttt{element\_attribute/8}. 

\begin{lstlisting}[style=asp-code, label={lst:results-xml-parse-attributes}, caption={Parsing XML attributes.}]
%% Extract attributes
tag_opening_attribute(TAG_NAME, t(tag_open, TOK_VALUE), LINE_NO, FROM, TO, attribute(NAME, VALUE)) :-
	tag_opening(TAG_NAME, t(tag_open, TOK_VALUE), LINE_NO, FROM, TO),
	&regex_matches[ATTRIBUTE_REGEX, TOK_VALUE](ATTRIBUTE_STR, _, _),
	attribute_regex(ATTRIBUTE_REGEX),
	&regex_matches[ATTRIBUTE_VALUE_REGEX, ATTRIBUTE_STR](VALUE, _, _), 
	attribute_value_regex(ATTRIBUTE_VALUE_REGEX),
	&regex_matches[ATTRIBUTE_NAME_REGEX, ATTRIBUTE_STR](NAME, _, _),
	attribute_name_regex(ATTRIBUTE_NAME_REGEX).

element_attribute(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO, attribute(NAME, VALUE)) :-
	element(TAG_NAME, OPEN_LINE_NO, OPEN_FROM, OPEN_TO, CLOSE_LINE_NO, CLOSE_FROM, CLOSE_TO),
	tag_opening_attribute(TAG_NAME, t(tag_open, _), OPEN_LINE_NO, OPEN_FROM, OPEN_TO, attribute(NAME, VALUE)).
\end{lstlisting} 

The final step in actual parsing of the XML content is to derive the complete hierarchy of all XML tags, i.e. determine which tags are direct children of another. This is done using the code from Listing~\ref{lst:results-xml-parse-hierarchy}. First, we establish elements that enclose other elements (i.e. opening and closing tag of the enclosed element between opening and closing tags of the enclosing element) using the rule on line 4. An element $e_1$ is not the parent element of an element $e_2$ enclosed by $e_1$ if there is a third element $e_i$ which is enclosed by $e_1$, but also encloses $e_2$. If, for any element encosing another element such an intermediate element exists, the rule from line 18 derives this as an instance of \texttt{element\_not\_parent/6}. An element $e_1$ \emph{is} the parent element of $e_2$ if it encloses $e_2$ and is not known to be not the parent. Element pairs fulfilling this definition are derived by the rule on line 22 and expressed as instances of \texttt{element\_parent/6}.

\begin{lstlisting}[style=asp-code, label={lst:results-xml-parse-hierarchy}, caption={Parsing XML attributes.}]
% Derive parent elements
% An element encloses another if the opening and closing tag of the enclosed 
% element lie fully between opening and cloising tags of the enclosing element
element_encloses(ENC, ENC_POS_FROM, ENC_POS_TO, LOWER, LOWER_POS_FROM, LOWER_POS_TO) :- 
	element(LOWER, LOWER_OPEN_LINE_NO, LOWER_OPEN_FROM, LOWER_OPEN_TO, LOWER_CLOSE_LINE_NO, LOWER_CLOSE_FROM, LOWER_CLOSE_TO),
	element(ENC, ENC_OPEN_LINE_NO, ENC_OPEN_FROM, ENC_OPEN_TO, ENC_CLOSE_LINE_NO, ENC_CLOSE_FROM, ENC_CLOSE_TO),
	token(LOWER_OPEN_TOK, LOWER_OPEN_LINE_NO, LOWER_OPEN_FROM, LOWER_OPEN_TO),
	token(LOWER_CLOSE_TOK, LOWER_CLOSE_LINE_NO, LOWER_CLOSE_FROM, LOWER_CLOSE_TO),
	token(ENC_OPEN_TOK, ENC_OPEN_LINE_NO, ENC_OPEN_FROM, ENC_OPEN_TO),
	token(ENC_CLOSE_TOK, ENC_CLOSE_LINE_NO, ENC_CLOSE_FROM, ENC_CLOSE_TO),
	token_before(ENC_OPEN_TOK, ENC_OPEN_LINE_NO, ENC_OPEN_FROM, ENC_OPEN_TO, LOWER_OPEN_TOK, LOWER_OPEN_LINE_NO, LOWER_OPEN_FROM, LOWER_OPEN_TO),
	token_before(LOWER_CLOSE_TOK, LOWER_CLOSE_LINE_NO, LOWER_CLOSE_FROM, LOWER_CLOSE_TO, ENC_CLOSE_TOK, ENC_CLOSE_LINE_NO, ENC_CLOSE_FROM, ENC_CLOSE_TO),
	ENC_POS_FROM = pos(ENC_OPEN_LINE_NO, ENC_OPEN_FROM),
	ENC_POS_TO = pos(ENC_CLOSE_LINE_NO, ENC_CLOSE_TO),
	LOWER_POS_FROM = pos(LOWER_OPEN_LINE_NO, LOWER_OPEN_FROM),
	LOWER_POS_TO = pos(LOWER_CLOSE_LINE_NO, LOWER_CLOSE_TO).
% An element E1 is parent of element E2 if E1 encloses E2 and there is no other element that encloses E2 and is enclosed byE1.   
element_not_parent(E, E_POS_FROM, E_POS_TO, P, P_POS_FROM, P_POS_TO) :- 
	element_encloses(P, P_POS_FROM, P_POS_TO, E, E_POS_FROM, E_POS_TO),
	element_encloses(P, P_POS_FROM, P_POS_TO, I, I_POS_FROM, I_POS_TO),
	element_encloses(I, I_POS_FROM, I_POS_TO, E, E_POS_FROM, E_POS_TO).
element_parent(E, E_POS_FROM, E_POS_TO, P, P_POS_FROM, P_POS_TO) :- 
	element_encloses(P, P_POS_FROM, P_POS_TO, E, E_POS_FROM, E_POS_TO),
	not element_not_parent(E, E_POS_FROM, E_POS_TO, P, P_POS_FROM, P_POS_TO).
\end{lstlisting}         