In this chapter, we discuss observations from the expirements conducted in Chapter~\ref{chap:results}. It is split into two main parts: In the first part, we discuss recurring patterns in code written in Evolog as observed on the model application written in Chapter~\ref{chap:results}. In the second part of this chapter, we take a look at the performance metrics gained from the testing described in Section~\ref{sec:results-performance-tests}.

\section{Observations from writing Evolog code}

Considering the example application discussed in Section~\ref{sec:results-xml-graphcol}, this section aims to highlight potential areas for improvement of the language.

\subsection{Unwrapping list terms}
As the examples in Section~\ref{sec:results-xml-graphcol} clearly show, there is a certain amount of boilerplate code involved whenever one has to "unpack" a list term obtained as an output term of a module literal. Since in most cases where list terms come into play, one actually wants to work on individual values on the list, we end up with many iterations of similar-looking code that is needed to transform one atom with a single list term into a set of "element atoms", each referring to one element of the list. An example of this is the subset of the 3-Coloring module (see Example~\ref{ex:3col-module}) where the module input (an atom referencing a list of vertices and a list of edges) is deconstructed in order to represent a graph using instances of predicates \texttt{vertex/1} and \texttt{edge/2}. The relevant part of the program is shown in Listing~\ref{lst:discussion-graph-unwrap}.

\begin{lstlisting}[style=asp-code, label={lst:discussion-graph-unwrap}, caption={Unwrapping list terms representing a graph}]
	vertex_element(V, TAIL) :- graph(lst(V, TAIL), _).
	vertex_element(V, TAIL) :- vertex_element(_, lst(V, TAIL)).
	vertex(V) :- vertex_element(V, _).
	edge_element(E, TAIL) :- graph(_, lst(E, TAIL)).
	edge_element(E, TAIL) :- edge_element(_, lst(E, TAIL)).
	edge(V1, V2) :- edge_element(edge(V1, V2), _).
\end{lstlisting}

The 6 lines of code shown in Listing~\ref{lst:discussion-graph-unwrap} deal with deconstructing two list terms, a vertex list and and edge list, respectively, into individual atoms such that each atom corresponds to one element of the list.
The transformation always follows the same pattern:
\begin{itemize}
    \item One rule derives an instance of an "element atom" from the head of the list, which is obtained by deconstructing the list term into the form \texttt{lst(V, TAIL)}, where \texttt{TAIL} is the rest of the list without the head value represented as variable \texttt{V}.
    \item A second rule recursively derives further list elements from element atoms by further deconstructing the \texttt{TAIL} terms of the individual element atoms. Repeated evaluation of this rule eventually leads to one element atom for every element of the original list term.
    \item Finally, a third rule derives the actual domain atoms we're interested in by projecting away the partial lists from the individual element atoms.
\end{itemize}    

Example~\ref{ex:discussion-graph-unwrapping} demonstrates this method of unwrapping list terms based on a list representation of the complete graph with 3 vertices $K_3$.

\begin{example}[List Unwrapping]
\label{ex:discussion-graph-unwrapping} 
Listing~\ref{lst:discussion-graph-unwrapping-example} shows the "graph unwrapping" program from Listing~\ref{lst:discussion-graph-unwrap} including a fact representing the complete graph $K_3$ encoded as two list terms.
\begin{lstlisting}[style=asp-code, label={lst:discussion-graph-unwrap}, caption={Unwrapping the list representation of $K_3$.}]
	graph(
		lst(a, lst(b, lst(c, lst_empty))),
		lst(edge(a, b), lst(edge(b, c), lst(edge(c, a), lst_empty)))).
	
	vertex_element(V, TAIL) :- graph(lst(V, TAIL), _).
	vertex_element(V, TAIL) :- vertex_element(_, lst(V, TAIL)).
	vertex(V) :- vertex_element(V, _).
	edge_element(E, TAIL) :- graph(_, lst(E, TAIL)).
	edge_element(E, TAIL) :- edge_element(_, lst(E, TAIL)).
	edge(V1, V2) :- edge_element(edge(V1, V2), _).
\end{lstlisting}
Listing ~\ref{lst:discussion-graph-unwrapped-example} shows the (single) answer set of the program given in Listing~\ref{lst:discussion-graph-unwrap}
\begin{lstlisting}[style=asp-code, label={lst:discussion-graph-unwrapped-example}, caption={The unwrapped list representation of $K_3$.}]
Answer set 1:
	{ edge(a, b)
	edge(b, c)
	edge(c, a)
	edge_element(edge(a, b), lst(edge(b, c), lst(edge(c, a), lst_empty)))
	edge_element(edge(b, c), lst(edge(c, a), lst_empty))
	edge_element(edge(c, a), lst_empty)
	graph(
		lst(a, lst(b, lst(c, lst_empty))), 
		lst(edge(a, b), lst(edge(b, c), lst(edge(c, a), lst_empty))))
	vertex(a)
	vertex(b)
	vertex(c)
	vertex_element(a, lst(b, lst(c, lst_empty)))
	vertex_element(b, lst(c, lst_empty))
	vertex_element(c, lst_empty) }
\end{lstlisting}
\end{example}    

\paragraph{Generalizing list-unrwapping}
As Example~\ref{ex:discussion-graph-unwrapping} demonstrates, unwrapping a list term always takes 3 rules that only differ in predicate names. Definition~\ref{def:discussion-list-extraction} introduces a potential "syntacic sugar" solution we call an \emph{unwrap rule}.

\begin{definition}[List-Unwrapping-Rule]
\label{def:discussion-list-extraction}
Given an Atom $a$ with terms $t_1,\ldots,t_k,\ldots,t_n$, where $t_k$ is a list term, we define the following rule to be the \emph{unwrap rule for $t_k$}:
\[
	e(V)~\leftarrow~\#unwrap\{ V~|~t_k \},~a(t_1,\ldots,t_k,\ldots,t_n).
\]
In the unwrap rule, $e(V)$ is called an \emph{element atom}, where $V$ refers to one value from the list $t_k$.
We define the semantics of the above rule to be equivalent to the following program:
\begin{align*}
	\mathit{list\_element}(V,\mathit{TAIL})~&\leftarrow~a(t_1,\ldots,\mathit{lst}(V,\mathit{TAIL}),\ldots,t_n).\\
	\mathit{list\_element}(V,\mathit{TAIL})~&\leftarrow~\mathit{list\_element}(\_,\mathit{lst}(V,\mathit{TAIL})).\\
	e(V)~&\leftarrow~\mathit{list\_element}(V,\_).
\end{align*}	
\end{definition}

Listing~\ref{lst:discussion-sugared-unwrap} shows a potential implementation of the 3-Coloring Module from Example~\ref{ex:3col-module} using the shorthand notation for list unwrapping proposed in Definition~\ref{def:discussion-list-extraction}.

\begin{lstlisting}[style=asp-code, label={lst:discussion-sugared-unwrap}, caption={3-Coloring Module with shorthand list unwrapping rules.}]
#module threecol(graph/2 => {col/2})  {
	% Unwrap input
	vertex(V) :- #unwrap{V | VLST}, graph(VLST, _).
	edge(V1, V2) :- #unwrap{edge(V1, V2) | ELST}, graph(_, ELST).

	% Make sure edges are symmetric
	edge(V2, V1) :- edge(V1, V2).

	% Guess colors
	red(V) :- vertex(V), not green(V), not blue(V).
	green(V) :- vertex(V), not red(V), not blue(V).
	blue(V) :- vertex(V), not red(V), not green(V).

	% Filter invalid guesses
	:- vertex(V1), vertex(V2), edge(V1, V2), red(V1), red(V2).
	:- vertex(V1), vertex(V2), edge(V1, V2), green(V1), green(V2).
	:- vertex(V1), vertex(V2), edge(V1, V2), blue(V1), blue(V2).

	col(V, red) :- red(V).
	col(V, blue) :- blue(V).
	col(V, green) :- green(V).
}
\end{lstlisting}	

\subsection{Repetitive File-IO Actions}

As we can observe in Listings~\ref{lst:results-xml-graphcol-userinput} and~\ref{lst:results-xml-graphcol-write-output}, respectively, reading the content of a file, as well as writing to a file require a set of rules that looks the same regardless of the specific file or content in question. Listing~\ref{lst:discussion-fileio-readlines} shows the "standard program" to read all lines from a file:
\begin{itemize}
	\item A file path (i.e. location in storage), represented using the fact \texttt{infile(PATH)} is opened.
	\item Assuming opening the file produced no error, the first line of content is read using the rule on line 11.
	\item Based on the first line read (line number 0), we recursively continue reading as long as reading the last line was successful and did not yield \texttt{eof} (i.e. a pseudo-term denoting the end of content) as a result.
	\item If \texttt{eof} has been read, the file is closed, and lines are represented as atoms of form \texttt{line(LINE\_NO, LINE)}.
\end{itemize}	

\begin{lstlisting}[style=asp-code, label={lst:discussion-fileio-readlines}, caption={Reading all lines from a file.}]
infile_open(PATH, HD) : @fileInputStream[PATH] = HD :- 
	infile(PATH).

% Handle file opening error
error(io, MSG) :- infile_open(_, error(MSG)).

% Read all lines from infile 
readline_result(PATH, 0, RES) : 
	@streamReadLine[STREAM] = RES :- 
	infile(PATH), infile_open(PATH, success(stream(STREAM))).
readline_result(PATH, LINE_NO, RES) : 
	@streamReadLine[STREAM] = RES :- 
	infile(PATH), 
	infile_open(PATH, success(stream(STREAM))), 
	readline_result(PATH, PREV_LINE_NO, PREV_LINE_RES), 
	PREV_LINE_RES != success(line(eof)), 
	LINE_NO = PREV_LINE_NO + 1.

% close stream after getting eof
infile_closed(PATH, RES) : 
	@inputStreamClose[STREAM] = RES :- 
	infile(PATH), 
	infile_open(PATH, success(stream(STREAM))),
	readline_result(PATH, _, ok(eof)).

% Extract actual lines and numbers
line(LINE_NO, LINE) :- 
	readline_result(PATH, LINE_NO, success(line(LINE))), 
	LINE != eof.
\end{lstlisting}	

The code to write a set of lines to a file looks similar to how a file is read. Listing~\ref{lst:discussion-fileio-writelines} demonstrates the typical implementation. The following steps are needed:
\begin{itemize}
	\item blabla
\end{itemize}	

\begin{lstlisting}[style=asp-code, label={lst:discussion-fileio-writelines}, caption={Writing lines to a file.}]

\end{lstlisting}	

\todo{do}