The idea of this work was to extend traditional answer set programming with a means to apply "side-effects", i.e. influence the outside world, from a program, while still preserving fully declarative semantics. 

To that end, we introduced the language extension \emph{Evolog} in Chapter~\ref{chap:language}, which is a conservative extension to the ASP language that is understood by the Alpha ASP solver. Evolog adds a formal representation of actions, which is defined in Section~\ref{sec:evolog-actions}, to ASP that is inspired by the Monad concept from functional programming in that it treats the state of the world on which side-effects are applied as input and output, respectively, of an action function. In Evolog, this is captured in the notion of a \emph{Frame}, which describes the interactions of a program with the outside world by means of an interpretation function for action rules. In order to enable an implementation of the action semantics which allows for programs with actions to be run on a physical computer with reasonable results, we defined necessary restrictions on the structure of those programs. The most important such restriction is that, whenever an action rule fires, the resulting atom must be part of an answer set, thereby ensuring that for every effect applied to the outside world, there is a witnessing atom in an answer set. In our reference implementation of said action semantics, in order to get to a condition that can actually be statically verified by an interpreter, we narrowed this to only allow actions in stratified programs. While this may seem like a rather large limitation, it neatly lines up with the fact that - even though ASP has multiple-model-semantics - we only run a given program on one computer at a time, so attempting to apply contradicting actions from multpile models would not be practical.

The second part of the Evolog extension is the program modularization concept defined in Section~\ref{sec:evolog-modules}. Modularization in Evolog treats modules which encapsulate sub-programs as a special kind of external atoms. By defining each answer set of a module program to constitute one ground substitution of the corresponding module atom, Evolog modules also provide a means to use program parts with multiple models (and guesses through e.g. the guess-and-check pattern) alongside Actions.

In Chapter~\ref{chap:implementation} we described our implementation of the Evolog extension, which is based on the lazy-grounding ASP solver Alpha, which we then tested by implementing a "real world" application, combining user interaction, file in- and output, parsing, as well as solving an NP-complete decision problem, in Chapter~\ref{chap:application-experiment}. We described a pure-Evolog implementation of an application that parses XML files representing graphs, on which we the search for three-colorings, and write the found colorings to an XML file. Chapter~\ref{chap:application-experiment} also contains some short performance test results from a variation of the XML-based 3-coloring application.

Last but not least, Chapter~\ref{chap:discussion} made an attempt to draw lessons for further improvement of the Evolog language extension as well as implementation performance from the code described in Chapter~\ref{chap:application-experiment} - we identified code constructs that are often repeated and discussed potential optimizations. Furthermore, we also discussed solving performance for Evolog programs, and sketched a possible approach to reducing the memory footprint of an Evolog program.

\section{Outlook}

While the work described here delivers a possible start on action semantics and a compatible modularization concept for (lazy-grounding) ASP solvers, it does not go beyond a first step, and there are a number of topics worth exploring further.

An intuitive first step to further improving the Evolog extension would be actually implementing the language constructs sketched in Section~\ref{sec:discussion-language-improvements}, namely syntactic shorthands for working with lists as well as composite actions. Furthermore, the current implementation does not support nested module calls, i.e. a module program cannot use another module. Since there is no semantic reason prohibiting this, it would suggest itself as a major improvement in the area of developer comfort.

Apart from developing language features, implementing additional applications using actions could lead to further insights. The actions provided for the reference implementation shown here are very centered around file input and output. While means to write to and read from file descriptors already enable a vast number of different programs, further actions, for example to interact with network sockets, or even build graphical user interfaces, would greatly increase the usability of Evolog as a potential general purpose programming language.